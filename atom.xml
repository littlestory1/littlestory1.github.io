<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://littlestory1.github.io</id>
    <title>昨日已逝，明日未知，而今日为金</title>
    <subtitle></subtitle>
    <icon>https://littlestory1.github.io/images/favicon.ico</icon>
    <link href="https://littlestory1.github.io" />
    <author>
      <name>alittlestory</name>
    </author>
    <updated>2023-11-24T12:57:49.000Z</updated>
    <entry>
        <id>https://littlestory1.github.io/2023/11/24/stm32/stm32-GPIO/</id>
        <title>stm32(GPIO)</title>
        <link rel="alternate" href="https://littlestory1.github.io/2023/11/24/stm32/stm32-GPIO/"/>
        <content type="html">&lt;h4 id=&#34;首先我们先来学习如何开时钟&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#首先我们先来学习如何开时钟&#34;&gt;#&lt;/a&gt; &lt;strong&gt;首先我们先来学习如何开时钟：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1：为什么需要开时钟？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以通俗的理解时钟是外设电路的心脏，不打开时钟就无法使用。每个外设都有独立时钟，如果不打开时钟外设就不能用，原因就是为了低功耗节省用电，不用的外设可以不打开时钟&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2：如何开启对应时钟？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我们需要看芯片对应的外设总线架构图&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;%E6%80%BB%E7%BA%BF%E6%9E%B6%E6%9E%84.jpg&#34; alt=&#34;总线架构&#34;&gt;&lt;/p&gt;
&lt;p&gt;假设我们现在需要开 GPIOA 的时钟，我们可以看到 GPIOA 是在 APB2 外设总线上的，那么开启 GPIOA 时钟代码如下：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;RCC_APB2PeriphClockCmd&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;RCC_APB2Periph_GPIOA&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; ENABLE&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;关闭时钟代码如下：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;figcaption data-lang=&#34;c&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token function&#34;&gt;RCC_APB2PeriphClockCmd&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;RCC_APB2Periph_GPIOA&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt; DISENABLE&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 id=&#34;一-gpio是什么&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#一-gpio是什么&#34;&gt;#&lt;/a&gt; 一、GPIO 是什么？&lt;/h4&gt;
&lt;p&gt;GPIO 全称 General Purpose Input Output 即通用输入 / 输出，其实 GPIO 的本质就是芯片的一个引脚，通常在 ARM 中所有的 I/O 都是通用的。不过由于每个开发板上都会设计不同的外围电路，这就造成 GPIO 的功能可能有所不同，大部分 GPIO 都是有复用功能的，比如有些 GPIO 可能是串口的 TX 或 RX，也可能是 I2C 的 SCL 或 SDA 线。&lt;/p&gt;
&lt;p&gt;所以我们不仅要知道 GPIO 能够输出高低电平，还要理解为什么有些 GPIO 可以复用某些功能，而其他的不可以。&lt;/p&gt;
&lt;h4 id=&#34;二-gpio内部结构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#二-gpio内部结构&#34;&gt;#&lt;/a&gt; 二、GPIO 内部结构&lt;/h4&gt;
&lt;p&gt;&lt;img data-src=&#34;GPIO%E7%BB%93%E6%9E%84%E5%9B%BE.jpg&#34; alt=&#34;GPIO结构图&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;gpio八种模式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#gpio八种模式&#34;&gt;#&lt;/a&gt; GPIO 八种模式&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;模式&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;浮空输入&lt;/td&gt;
&lt;td&gt;GPIO_Mode_IN_FLOATING&lt;/td&gt;
&lt;td&gt;若引脚悬空，则电平不确定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;上拉输入&lt;/td&gt;
&lt;td&gt;GPIO_Mode_IPU&lt;/td&gt;
&lt;td&gt;内部连接上拉电阻，悬空时默认高电平&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;下拉输入&lt;/td&gt;
&lt;td&gt;GPIO_Mode_IPD&lt;/td&gt;
&lt;td&gt;内部连接下拉电阻，悬空时默认低电平&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模拟输入&lt;/td&gt;
&lt;td&gt;GPIO_Mode_AIN&lt;/td&gt;
&lt;td&gt;GPIO 无效，引脚直接接入内部 ADC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开漏输出&lt;/td&gt;
&lt;td&gt;GPIO_Mode_Out_OD&lt;/td&gt;
&lt;td&gt;高电平为高阻态，低电平接 VSS（负极）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;推挽输出&lt;/td&gt;
&lt;td&gt;GPIO_Mode_Out_PP&lt;/td&gt;
&lt;td&gt;高电平接 VDD，低电平接 VSS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;复用开漏输出&lt;/td&gt;
&lt;td&gt;GPIO_Mode_AF_OD&lt;/td&gt;
&lt;td&gt;由片上外设控制，高电平为高阻态，低电平接 VSS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;复用推挽输出&lt;/td&gt;
&lt;td&gt;GPIO_Mode_AF_PP&lt;/td&gt;
&lt;td&gt;由片上外设控制，高电平接 VDD，低电平接 VSS&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;名词解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高阻态：是一个数字电路里常见的术语，指的是电路的一种输出状态，既不是高电平也不是低电平，如果高阻态再输入下一级电路的话，对下级电路无任何影响，和没接一样，如果用万用表测的话有可能是高电平也有可能是低电平，随它后面接的东西定的。电路分析时高阻态可做开路理解。你可以把它看作输出（输入）电阻非常大。它的极限状态可以认为悬空（开路）。也就是说理论上高阻态不是悬空，它是对地或对电源电阻极大的状态。而实际应用上与引脚的悬空几乎是一样的。&lt;/p&gt;
</content>
        <category term="stm32单片机" scheme="https://littlestory1.github.io/categories/stm32/" />
        <category term="stm32" scheme="https://littlestory1.github.io/tags/stm32/" />
        <updated>2023-11-24T12:57:49.000Z</updated>
    </entry>
    <entry>
        <id>https://littlestory1.github.io/2023/11/21/stm32/stm32%EF%BC%88%E5%89%8D%E8%A8%80%EF%BC%89/</id>
        <title>stm32前言</title>
        <link rel="alternate" href="https://littlestory1.github.io/2023/11/21/stm32/stm32%EF%BC%88%E5%89%8D%E8%A8%80%EF%BC%89/"/>
        <content type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要用于记录 stm32 的知识点以及学习过程，这样慢慢积累下来，会有莫名的成就感&lt;/p&gt;
&lt;p&gt;如果有误，欢迎加我 qq 指出错误&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用板子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;stm32f103c8t6 最小系统板&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stm32 三种开发方式的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;寄存器模式&lt;/strong&gt;：最底层的开发，运行速度最快。实际上也是使用了固件库，但是不是使用固件库的函数，而是使用了固件库的定义，包括宏定义，结构体定义。和 51 的开发差不多，但因为 32 的寄存器太多，实际开发手动配置大量寄存器极其耗费时间，同时在没有注释的情况下可读性差，所以较少使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标准库模式&lt;/strong&gt;：基于寄存器进行了函数的封装，而由于函数封装以及内部大量的检查参数有效性的代码，运行速度相对于寄存器模式较慢。封装之后可以根据函数名字就能明白代码作用，容易记忆，使用方便，所以较多人使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HAL 库模式&lt;/strong&gt;：全称是 Hardware Abstraction Layer（抽象印象层），相比于标准库更加深入的封装，有句柄、回调函数等概念，因此相对于标准库模式有更好的可移植性（可在不同芯片的移植），但代价就是更多的性能损失。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;本系列采用标准库模式&lt;/strong&gt;&lt;/p&gt;
</content>
        <category term="stm32单片机" scheme="https://littlestory1.github.io/categories/stm32/" />
        <category term="stm32" scheme="https://littlestory1.github.io/tags/stm32/" />
        <updated>2023-11-21T14:38:11.000Z</updated>
    </entry>
    <entry>
        <id>https://littlestory1.github.io/2023/11/21/note/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
        <title>第一篇博客</title>
        <link rel="alternate" href="https://littlestory1.github.io/2023/11/21/note/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
        <content type="html">&lt;p&gt;觉得原本的博客主题过于花里胡哨，于是换了个主题，然后把全部文章删了，重新整理，重新写&lt;/p&gt;
</content>
        <category term="杂谈" scheme="https://littlestory1.github.io/categories/note/" />
        <category term="杂谈" scheme="https://littlestory1.github.io/tags/%E6%9D%82%E8%B0%88/" />
        <updated>2023-11-21T14:23:55.000Z</updated>
    </entry>
</feed>
