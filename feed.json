{
    "version": "https://jsonfeed.org/version/1",
    "title": "昨天是段历史，明天是个谜团，而今天是天赐的礼物",
    "subtitle": "",
    "icon": "http://example.com/images/favicon.ico",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/11/21/stm32/stm32%EF%BC%88%E5%89%8D%E8%A8%80%EF%BC%89/",
            "url": "http://example.com/2023/11/21/stm32/stm32%EF%BC%88%E5%89%8D%E8%A8%80%EF%BC%89/",
            "title": "stm32前言",
            "date_published": "2023-11-21T14:38:11.000Z",
            "content_html": "<p><strong>前言</strong></p>\n<p>主要用于记录 stm32 的知识点以及学习过程，这样慢慢积累下来，会有莫名的成就感</p>\n<p>如果有误，欢迎加我 qq 指出错误</p>\n<p><strong>使用板子：</strong></p>\n<p>stm32f103c8t6 最小系统板</p>\n<p><strong>stm32 三种开发方式的区别</strong></p>\n<ul>\n<li><strong>寄存器模式</strong>：最底层的开发，运行速度最快。实际上也是使用了固件库，但是不是使用固件库的函数，而是使用了固件库的定义，包括宏定义，结构体定义。和 51 的开发差不多，但因为 32 的寄存器太多，实际开发手动配置大量寄存器极其耗费时间，同时在没有注释的情况下可读性差，所以较少使用。</li>\n<li><strong>标准库模式</strong>：基于寄存器进行了函数的封装，而由于函数封装以及内部大量的检查参数有效性的代码，运行速度相对于寄存器模式较慢。封装之后可以根据函数名字就能明白代码作用，容易记忆，使用方便，所以较多人使用。</li>\n<li><strong>HAL 库模式</strong>：全称是 Hardware Abstraction Layer（抽象印象层），相比于标准库更加深入的封装，有句柄、回调函数等概念，因此相对于标准库模式有更好的可移植性（可在不同芯片的移植），但代价就是更多的性能损失。</li>\n</ul>\n",
            "tags": [
                "stm32单片机",
                "stm32"
            ]
        },
        {
            "id": "http://example.com/2023/11/21/note/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/",
            "url": "http://example.com/2023/11/21/note/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/",
            "title": "第一篇博客",
            "date_published": "2023-11-21T14:23:55.000Z",
            "content_html": "<p>觉得原本的博客主题过于花里胡哨，于是换了个主题，然后把全部文章删了，重新整理，重新写</p>\n",
            "tags": [
                "杂谈",
                "杂谈"
            ]
        }
    ]
}